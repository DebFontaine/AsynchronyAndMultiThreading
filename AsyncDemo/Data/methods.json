[
{
  "name": "ExamplePlainThreads",
  "code": "\r\npublic override Action GetAction()\r\n        {\r\n            return () =\u003E\r\n            {\r\n                RaiseMessageGenerated(\u0022Executing Plain Threads...\u0022 \u002B \u0022\\n\u0022);\r\n                RaiseMessageGenerated(\u0022Cores count: \u0022 \u002B Environment.ProcessorCount \u002B \u0022\\n\u0022);\r\n                RaiseMessageGenerated(\u0022Main thread\u0027s ID: \u0022 \u002B Thread.CurrentThread.ManagedThreadId \u002B \u0022\\n\u0022);\r\n\r\n                Stopwatch stopwatch = Stopwatch.StartNew();\r\n                Thread thread1 = new Thread(() =\u003E PrintPluses(1000));\r\n                Thread thread2 = new Thread(() =\u003E PrintMinuses(1000));\r\n\r\n                thread1.Start();\r\n                thread2.Start();\r\n                stopwatch.Stop();\r\n                RaiseMessageGenerated(\u0022Took: \u0022 \u002B stopwatch.ElapsedMilliseconds \u002B \u0022 ms to start 2 Threads threads\\n\u0022);\r\n            };\r\n        }",
  "comment": "Creating threads using the thread class will allow seperate sets of instructions to run 'concurrently'. Note this does not necessarily mean they will run in parallel. If your machine has only one core, the task scheduler will use time slices to run the tasks at the same time. If one of the tasks can not be finished in a single time slice then the scheduler will give it another time slice after other instructions have had their turn.\r\n \r\nIn this example the two threads are running concurrently (or in parallel) which is why you see a mix of plusses and minuses in the output. Also notice how the comment 'Took: 4 ms...' is printed before any of the pluses or minusses even though it is near the end of the code block\r\n\r\n Another thing to note is that while each thread has it's own stack, all threads in a process share the same heap. This is why it's important to use synchronization mechanisms like locks when writing multi-threaded programs."
},
{
  "name": "ExampleThreadPool",
  "code": "\r\nstatic void ExampleThreadPool()\r\n{\r\n    const int iterations = 100;\r\n    Stopwatch stopwatch = Stopwatch.StartNew();\r\n\r\n    for (int i = 0; i \u003C iterations; i\u002B\u002B)\r\n    {\r\n        ThreadPool.QueueUserWorkItem(PrintA);\r\n    }\r\n    stopwatch.Stop();\r\n    Console.WriteLine(\u0022Took: \u0022 \u002B stopwatch.ElapsedMilliseconds);\r\n}",
  "comment": "Creating threads using the .net ThreadPool is less expensive than creating individual threads using the Thread class. That's because .net creates a set of Threads initially in the pool and will resuse them as threads complete their work.\r\n\r\nIn this example you can see that 1000 threads were started but execution continued in the main thread which is why the 'Took: x ms...' message appears befor the 'A's which are printed by the indivisual Threadpool threads"
},
{
  "name": "ExampleTasks",
  "code": "\r\nstatic void ExampleTasks()\r\n{\r\n    Task task1 = Task.Run(() =\u003E PrintPluses(1000));\r\n    Task task2 = Task.Run(() =\u003E PrintMinuses(1000));\r\n}",
  "comment": "The Task Parallel Library (TPL) allows us to use higher level mechanisms like the Task class to implment multithreading and asynchrony. A Task represents a unit of work that can be executed asynchronously on a separate thread. Behind the scenes TPL uses the Threadpool to queue tasks.\r\n\r\nTasks contain methods and properties that allow us to do things like cancel a task, continue with other execution after a task is finished and much more. You can see that this code runs similarly to the Thread and Threadpool examples - the plusses are minuses are mixed up because the tasks are running concurrently.\r\n\r\nTasks can also return reults so you might have something like\r\n\r\n    Task<int> taskFromResult =Task.Run(() => Divide(10, 2));\r\n\r\nwhere you can think of Task<int> as capable of producing an int but it's not an int until the Task completes. There are various ways to wait for the result including using the Result property of the task object but this is a blocking operation. The main thread will stop and be unusable - it is like running synchronously."
},
{
  "name": "ExampleWaitAll",  
  "code": "\r\nstatic void ExampleWaitAll()\r\n{\r\n    var task3 = Task.Run(() =\u003E\r\n    {\r\n        Thread.Sleep(1000);\r\n        Console.WriteLine(\u0022Task 1 is finished.\u0022);\r\n    });\r\n    var task4 = Task.Run(() =\u003E\r\n    {\r\n        Thread.Sleep(1000);\r\n        Console.WriteLine(\u0022Task 2 is finished.\u0022);\r\n    });\r\n\r\n    Task.WaitAll(task3, task4);\r\n}",
  "comment": "Wait and WaitAll are useful when dealing with Tasks that do not return a value since those do not have a Result property. Wait and WaitAll also block the calling thread."
},
{
  "name": "ExampleContinuationsContinueWith", 
  "code": "\r\nstatic void ExampleContinuationsContinueWith()\r\n{\r\n    Task taskContinuation =\r\n        Task.Run(() =\u003E CalculateLength(\u0022Hello there\u0022))\r\n        .ContinueWith(taskWithResult =\u003E\r\n        Console.WriteLine(\u0022Length is \u0022 \u002B taskWithResult.Result))\r\n        .ContinueWith(completedTask =\u003E\r\n        {\r\n            Thread.Sleep(500);\r\n            Console.WriteLine(\u0022The second continuation.\u0022);\r\n        });\r\n\r\n\r\n}",
  "comment": "Continuations allow you to wait for Task completion in a non-blocking way. Continuations can be chained together and/or executed only when the Task has a certain status (Faulted, completed etc).\r\nA Continuation is code that will be exectued after a Task is completed. When you run this example you can see that first the length was calculated, the the length was printed and then the second continuation was executed. Again this code will not block the main thread."
},
{
  "name": "ExampleContinuationsContinueWhenAll", 
  "code": "\r\nstatic void ExampleContinuationsContinueWhenAll()\r\n{\r\n    var tasks = new[]\r\n  {\r\n    Task.Run(() =\u003E CalculateLength(\u0022hello there\u0022)),\r\n    Task.Run(() =\u003E CalculateLength(\u0022hi\u0022)),\r\n    Task.Run(() =\u003E CalculateLength(\u0022hola\u0022)),\r\n  };\r\n\r\n    var continuationTask = Task.Factory.ContinueWhenAll(\r\n        tasks,\r\n        completedTasks =\u003E Console.WriteLine(\r\n            string.Join(\u0022, \u0022, completedTasks.Select(task =\u003E task.Result))));\r\n}",
  "comment": "Continuations allow you to wait for Task completion in a non-blocking way. Continuations can be chained together and/or executed only when the Task has a certain status (Faulted, completed etc).\r\nA Continuation is code that will be exectued after a Task is completed. In this example the Contiuation does not get executed to all tasks in the array are completed. Again this code will not block the main thread."
},
{
  "name": "ExampleChildTasks",  
  "code": "\r\nstatic void ExampleChildTasks()\r\n{\r\n    //child tasks\r\n    var parent = Task.Run(() =\u003E\r\n    {\r\n        Console.WriteLine(\u0022Parent task executing.\u0022);\r\n\r\n        var child = Task.Run(() =\u003E\r\n        {\r\n            Console.WriteLine(\u0022Child task starting.\u0022);\r\n        });\r\n    });\r\n}",
  "comment": ""
},
{
  "name": "ExampleTaskFromResult",
  "code": "\r\nstatic void ExampleTaskFromResult()\r\n{\r\n    Task\u003Cint\u003E taskFromResult = Task.FromResult(10);\r\n}",
  "comment": ""
},
{
  "name": "ExampleCancellingTasks",
  "code": "\r\npublic override Action GetAction()\r\n        {\r\n            return () =\u003E\r\n            {              \r\n                var task = Task.Run(\r\n                    () =\u003E NeverendingMethod(_cancellationTokenSource),\r\n                    _cancellationTokenSource.Token)\r\n                    .ContinueWith(canceledTask =\u003E\r\n                        RaiseMessageGenerated($\u0022\\nTask with ID {canceledTask.Id} has been canceled.\u0022),\r\n                        TaskContinuationOptions.OnlyOnCanceled);\r\n            };\r\n        }\r\n        public override void CancelTask()\r\n        {\r\n            _cancellationTokenSource?.Cancel();\r\n        }\r\n        private void NeverendingMethod(CancellationTokenSource cancellationTokenSource)\r\n        {\r\n            while (true)\r\n            {\r\n                cancellationTokenSource.Token.ThrowIfCancellationRequested();\r\n                RaiseMessageGenerated(\u0022Working...\u0022);\r\n                Thread.Sleep(1500);\r\n            }\r\n        }",
  "comment": "TPL uses 'cooperative cancellation' which basically means the code requesting cancellation and the Task to be cancelled need to work together. In this method you can see we use a CancellationTokenSource which is passed into the task that needs to be cancelled. There is also a CancelTask method which will be triggered if you hit the 'Cancel Task' button while the code is running. The task will be cancelled"
},
{
  "name": "ExampleAggregateException",
  "code": "\r\nstatic void ExampleAggregateException()\r\n{\r\n    var taskThatMayFault = Task.Run(() =\u003E Divide(2, 0))\r\n        .ContinueWith(\r\n        faultedTask =\u003E\r\n        {\r\n            faultedTask.Exception.Handle(ex =\u003E\r\n            {\r\n                Console.WriteLine(\u0022Division task finished\u0022);\r\n                if (ex is ArgumentNullException)\r\n                {\r\n                    Console.WriteLine(\u0022Arguments can\u0027t be null.\u0022);\r\n                    return true;\r\n                }\r\n                if (ex is DivideByZeroException)\r\n                {\r\n                    Console.WriteLine(\u0022Can\u0027t divide by zero.\u0022);\r\n                    return true;\r\n                }\r\n                Console.WriteLine(\u0022Unexpected exception type.\u0022);\r\n                return false;\r\n            });\r\n        },\r\n        TaskContinuationOptions.OnlyOnFaulted);\r\n}",
  "comment": ""
},
{
  "name": "ExampleMultipleContinuations",
  "code": "\r\nstatic void ExampleMultipleContinuations()\r\n{\r\n    var taskWithMultipleContinuations = new Task(() =\u003E Divide(10, 2));\r\n\r\n    taskWithMultipleContinuations.ContinueWith(faultedTask =\u003E\r\n        Console.WriteLine(\u0022Success\u0022),\r\n        TaskContinuationOptions.OnlyOnRanToCompletion);\r\n\r\n    taskWithMultipleContinuations.ContinueWith(faultedTask =\u003E\r\n        Console.WriteLine(\u0022Exception thrown: \u0022 \u002B faultedTask.Exception.Message),\r\n        TaskContinuationOptions.OnlyOnFaulted);\r\n\r\n    taskWithMultipleContinuations.Start();\r\n}",
  "comment": ""
},
{
  "name": "ExampleLockSynchronization",
  "code": "\r\nstatic void ExampleLockSynchronization()\r\n{\r\n    var counter = new Counter();\r\n\r\n    var tasksAccessingTheSameResource = new List\u003CTask\u003E();\r\n\r\n    for (int i = 0; i \u003C 10; i\u002B\u002B)\r\n    {\r\n        tasksAccessingTheSameResource.Add(Task.Run(() =\u003E counter.Increment()));\r\n    }\r\n    for (int i = 0; i \u003C 10; i\u002B\u002B)\r\n    {\r\n        tasksAccessingTheSameResource.Add(Task.Run(() =\u003E counter.Decrement()));\r\n    }\r\n\r\n    Task.WaitAll(tasksAccessingTheSameResource.ToArray());\r\n    Console.WriteLine(\u0022Counter value is: \u0022 \u002B counter.Value);\r\n}",
  "comment": "Multiple tasks are incrementing the Counter value. If we didn't use a lock we could get unpredictable results because the i++ is not an atomic operation - it actually has 2 steps under the hood. If one of the threads increments the counter value during the first step of the other thread, we will get an incorrect value - that is an example of a race condition. The lock is put around a critical section of the code and prevents more than one thread from accessing shared data."
},
{
  "name": "ExampleAsyncAndAwait",
  "code": "\r\npublic override Action GetAction()\r\n        {\r\n            return () =\u003E\r\n            {\r\n                var taskFromAsyncMethod = Process(\u0022Fun with async and await\u0022);\r\n                RaiseMessageGenerated(\u0022\\nBack in original caller.\\n\u0022);\r\n\r\n            };\r\n        }\r\n        private async Task\u003Cint\u003E CalculateLengthAsync(string input)\r\n        {\r\n            RaiseMessageGenerated(\u0022Starting the CalculateLengthAsync method\u0022);\r\n            await Task.Delay(2000);\r\n            RaiseMessageGenerated(\u0022\\nCalculateLengthAsync is done\\n\u0022);\r\n            return input.Length;\r\n        }\r\n        private async Task Process(string input)\r\n        {\r\n            try\r\n            {\r\n                var length = await CalculateLengthAsync(input);\r\n                //control will go back to caller until the Calculate\r\n                //LengthAsync is completed\r\n\r\n                //Once complete then PrintAsync will be invoked\r\n                await PrintAsync(length);\r\n                //control will again go back to caller until PrintAsync is done\r\n                RaiseMessageGenerated(\u0022\\nThe process is finished.\\n\u0022);\r\n            }\r\n            catch (NullReferenceException ex)\r\n            {\r\n                RaiseMessageGenerated(\u0022\\nThe input can\u0027t be null.\\n\u0022);\r\n            }\r\n        }\r\n        private async Task PrintAsync(int result)\r\n        {\r\n            RaiseMessageGenerated(\u0022\\nStarting the Print method\\n\u0022);\r\n            await Task.Delay(2000);\r\n            RaiseMessageGenerated(\u0022The result is \u0022 \u002B result \u002B \u0022.\\nPrint method is done\u0022);\r\n        }",
  "comment": "This code basically replaces the cumbersome Task, Run, Continue used here\r\n\r\n var task = Task.Run(() => CalculateLength('Hello')\r\n.ContinueWith(completedTask => Print(completedTask.Result))\r\n\t.ContinueWith(previousContinuation => Console.WriteLine('The process is finished.'))\r\n\r\n By using await we tell the calculation to start but don't wait around. Instead go back to caller. Don't process the line after the line with te await keyword until after the awaited Task is done. You can think of the line with the await as the 'task.run' and the line after the await keyword as the 'continuation'\r\n\r\n The 'async' method modifier specifies that some part of the method runs asynchronously. Code before the await keyword actually runs synchronously. Once the line with the await keyword is hit, the async method is suspended until the awaited Task completes. Control returns to the caller until the task is completed.\r\n\r\n Once the awaited task is completed, the continuation (i.e. the next code statement) will be executed. NOTE: The continuation may run on a different thread than the Task that preceded it. When a continuation is scheduled the Threadpool is involved and the runtime will give us any available thread which could be different. \r\n\r\n Tasks that are awaited must return a Task or Task<int>, Taks<string> etc. The await keyword willl unwrap the Task result to assign to the variable."
}
]
